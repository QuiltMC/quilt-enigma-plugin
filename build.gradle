import proguard.gradle.ProGuardTask

buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
		classpath 'com.guardsquare:proguard-gradle:7.4.0'
	}
}

plugins {
	id 'java'
	id 'maven-publish'
	id 'checkstyle'
	id 'org.quiltmc.gradle.licenser' version '2.0.1'
	id 'qmap-diff'
}

version '2.4.0'
group 'org.quiltmc'

final ENV = System.getenv()

version = version + (ENV.GITHUB_ACTIONS ? '' : '+local')

qMapDiff {
	projectVersion = project.version.toString()
}

sourceSets {
	testInputs
}

repositories {
	mavenCentral()
	maven {
		name 'Quilt Repository'
		url 'https://maven.quiltmc.org/repository/release/'
	}
	maven {
		name 'Quilt Snapshots'
		url 'https://maven.quiltmc.org/repository/snapshot/'
	}
	mavenLocal()

	// Enigma dependencies
	maven {
		url 'https://maven.fabricmc.net/'
		content {
			includeModule('net.fabricmc', 'cfr')
		}
	}

	// Test inputs dependencies
	maven {
		name 'Minecraft Libraries'
		url 'https://libraries.minecraft.net'
	}
}

sourceSets {
	commonTestInputs
}

configurations {
	enigmaRuntime
}

dependencies {
	implementation libs.bundles.asm
	implementation libs.enigma
	implementation libs.quilt.json5
	implementation libs.tinylog
	implementation libs.annotations
	implementation libs.gson

	testImplementation libs.junit
	testImplementation libs.hamcrest
	testRuntimeOnly libs.junit.engine
	testImplementation libs.enigma.swing

	enigmaRuntime libs.dfu
}

TaskProvider<Jar> registerTestInputJarTask(String namePrefix, Object... sourcePaths) {
	return tasks.register("${namePrefix}TestJar", Jar) {
		group('test-setup')

		from(sourcePaths)

		archiveFileName = "${namePrefix}-test.jar"
		destinationDirectory = project.layout.buildDirectory.dir('test-inputs')
	}
}

TaskProvider<ProGuardTask> registerTestInputObfTask(String namePrefix, TaskProvider<Jar> jarTask, Object libraryJarFiles) {
	final testObf = tasks.register("${namePrefix}TestObf", ProGuardTask) {
		group('test-setup')

		final obfDest = project.layout.buildDirectory.dir('test-obf')

		verbose()
		injars jarTask.flatMap { it.archiveFile }
		outjars obfDest.zip(jarTask.flatMap(Jar::getArchiveFileName)) { dest, jarName ->
			dest.file("${jarName.substring(0, jarName.length() - 4)}-obf.jar")
		}

		libraryjars "${System.getProperty('java.home')}/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
		libraryjars libraryJarFiles

		dontshrink()
		dontoptimize()
		keepclasseswithmembers 'public class * {\
\t\tpublic static void main(java.lang.String[]);\
\t}'
		keepattributes 'SourceFile'
		keepattributes '*Annotation*'
		keepattributes 'InnerClasses'
		keepattributes 'NestMembers'
		keepattributes 'EnclosingMethod'
		keepattributes 'Deprecated'
		keepattributes 'Signature'
		keepattributes 'Record'
		printmapping obfDest.map { it.file("${namePrefix}-test-obf.txt") }
	}

	test.dependsOn(testObf)

	return testObf
}

final completeTestInputSources = project.files()
final completeTestInputSourcesExclude = project.files()
final completeTestInputClasspath = project.files()

file('src/testInputs/').listFiles().each { dir ->
	if (dir.directory) {
		sourceSets {
			"${dir.name}" {
				java {
					srcDirs dir.toPath().resolve('java')
				}

				resources {
					final resourcesDir = dir.toPath().resolve('resources')
					srcDirs resourcesDir

					completeTestInputSourcesExclude.from(resourcesDir)
				}
			}
		}

		final SourceSet sourceSet = sourceSets."${dir.name}"

		dependencies {
			"${dir.name}Implementation"(libs.dfu)
		}

		final testJar = registerTestInputJarTask(dir.name, sourceSet.output)
		completeTestInputSources.from(sourceSet.output)

		final testObf = registerTestInputObfTask(dir.name, testJar, sourceSet.compileClasspath)
		completeTestInputClasspath.from(sourceSet.compileClasspath)
	}
}

final completeTestJar = registerTestInputJarTask('complete', completeTestInputSources.filter { file ->
	!completeTestInputSourcesExclude.contains(file)
})
completeTestJar.configure {
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
final completeTestObf = registerTestInputObfTask('complete', completeTestJar, completeTestInputClasspath)

tasks.register('testEnigma', JavaExec) {
	final completeObf = completeTestObf.map(ProGuardTask::getOutJarFileCollection).map(FileCollection::getSingleFile)
	final mappings = file('testMappings/')

	final profile = file('enigma_test/profile.json')

	inputs.files(completeObf, profile)
	outputs.dir(mappings)

	mainClass = "org.quiltmc.enigma.gui.Main"
	classpath = files(configurations.enigmaRuntime) + sourceSets.test.runtimeClasspath

	doFirst {
		args(
			'-jar', completeObf.get(),
			'-mappings', mappings.getAbsolutePath(),
			'-profile', profile,
			'--development'
		)
		mappings.mkdirs()
	}
}

license {
	rule file('codeformat/FABRIC_MODIFIED_HEADER')
	rule file('codeformat/HEADER')

	include '**/*.java'
	exclude 'com/example/**/*.java'
}

java {
	sourceCompatibility = JavaVersion.VERSION_17
	targetCompatibility = JavaVersion.VERSION_17

	withSourcesJar()
}

test {
	useJUnitPlatform()
	dependsOn processCommonTestInputsResources
}

publishing {
	publications {
		maven(MavenPublication) {
			from components.java
		}
	}

	repositories {
		if (ENV.MAVEN_URL) {
			maven {
				url = ENV.MAVEN_URL

				credentials {
					username = ENV.MAVEN_USERNAME
					password = ENV.MAVEN_PASSWORD
				}
			}
		}
		mavenLocal()
	}
}
