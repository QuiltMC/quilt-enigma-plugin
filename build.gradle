import java.nio.file.Files
import java.util.regex.Pattern

buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
		classpath 'com.guardsquare:proguard-gradle:7.4.0'
	}
}

plugins {
	id 'java'
	id 'maven-publish'
	id 'checkstyle'
	id 'org.quiltmc.gradle.licenser' version '2.0.1'
}

version '2.3.1'
group 'org.quiltmc'

final ENV = System.getenv()
interface ExecProvider {
	@javax.inject.Inject
	ExecOperations getOperations()
}
final EXEC = objects.newInstance(ExecProvider).operations

version = version + (ENV.GITHUB_ACTIONS ? '' : '+local')

sourceSets {
	testInputs
}

repositories {
	mavenCentral()
	maven {
		name 'Quilt Repository'
		url 'https://maven.quiltmc.org/repository/release/'
	}
	maven {
		name 'Quilt Snapshots'
		url 'https://maven.quiltmc.org/repository/snapshot/'
	}
	mavenLocal()

	// Enigma dependencies
	maven {
		url 'https://maven.fabricmc.net/'
		content {
			includeModule('net.fabricmc', 'cfr')
		}
	}

	// Test inputs dependencies
	maven {
		name 'Minecraft Libraries'
		url 'https://libraries.minecraft.net'
	}
}

configurations {
	enigmaRuntime
}

dependencies {
	implementation libs.bundles.asm
	implementation libs.enigma
	implementation libs.quilt.json5
	implementation libs.tinylog
	implementation libs.annotations
	implementation libs.gson

	testImplementation libs.junit
	testImplementation libs.hamcrest
	testRuntimeOnly libs.junit.engine
	testImplementation libs.enigma.swing

	testInputsImplementation libs.dfu
	enigmaRuntime libs.dfu
}

var obfJar = file('build/obf/obf.jar')
var mappings = file('testMappings/')
var profile = file('build/resources/testInputs/profile.json')

tasks.register('testEnigma', JavaExec) {
	dependsOn "obfuscateTestInputs", "processTestInputsResources"
	mainClass = "org.quiltmc.enigma.gui.Main"
	classpath = files(configurations.enigmaRuntime) + sourceSets.test.runtimeClasspath

	args('-jar', obfJar, '-mappings', mappings.getAbsolutePath(), '-profile', profile.getAbsolutePath(), '--development')
	doFirst {
		mappings.mkdirs()
	}
}

tasks.register('testInputsJar', Jar) {
	from sourceSets.testInputs.output

	archiveFileName = "input.jar"
	destinationDirectory = file("build/obf")
}

tasks.register('obfuscateTestInputs', proguard.gradle.ProGuardTask) {
	dependsOn testInputsJar

	verbose
	injars testInputsJar
	outjars obfJar

	libraryjars "${System.getProperty('java.home')}/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
	libraryjars sourceSets.testInputs.compileClasspath

	dontshrink()
	dontoptimize()
	keepclasseswithmembers 'public class * {\
\t\tpublic static void main(java.lang.String[]);\
\t}'
	keepattributes 'SourceFile'
	keepattributes '*Annotation*'
	keepattributes 'InnerClasses'
	keepattributes 'NestMembers'
	keepattributes 'EnclosingMethod'
	keepattributes 'Deprecated'
	keepattributes 'Signature'
	keepattributes 'Record'
	printmapping 'build/obf/obf.txt'
}

tasks.test.dependsOn obfuscateTestInputs, processTestInputsResources

static void replaceRegion(File file, String replacement, int start, int end) {
	file.text = replaceRegion(file.text, replacement, start, end)
}

static String replaceRegion(String string, String replacement, int start, int end) {
	return string.substring(0, start) + replacement + string.substring(end)
}

static void deleteFullDir(java.nio.file.Path dir) {
	final contentsItr = Files.newDirectoryStream(dir).iterator()

	while(contentsItr.hasNext()) {
		final content = contentsItr.next()
		if (Files.isDirectory(content)) {
			deleteFullDir(content)
		}

		try {
			Files.delete(content)
		} catch (Exception e) {
			System.err.println("Failed to delete: $e")
		}
	}
}

// tasks.register('setupQmap') {
// 	final destProvider = layout.buildDirectory.dir('quilt-mappings')
// 	final projectVersion = project.version
//
// 	inputs.property('projectVersion', projectVersion)
// 	outputs.tap {
// 		dir(destProvider)
// 		// upToDateWhen {
// 		// 	final dest = destProvider.get().asFile.toPath()
// 		// 	if (!dest.resolve('.git').toFile().exists()) {
// 		// 		return false
// 		// 	}
// 		//
// 		// 	EXEC.exec {
// 		// 		workingDir dest
// 		// 		executable 'git'
// 		// 		args 'fetch'
// 		// 	}
// 		//
// 		// 	final localHash = new ByteArrayOutputStream()
// 		// 	EXEC.exec {
// 		// 		workingDir dest
// 		// 		executable 'git'
// 		// 		args 'rev-parse', 'HEAD'
// 		// 		standardOutput = localHash
// 		// 	}
// 		//
// 		// 	final originHash = new ByteArrayOutputStream()
// 		// 	EXEC.exec {
// 		// 		workingDir dest
// 		// 		executable 'git'
// 		// 		args 'rev-parse', 'origin/HEAD'
// 		// 		standardOutput = originHash
// 		// 	}
// 		//
// 		// 	final sameHash = originHash == localHash
// 		// 	return sameHash
// 		// }
// 	}
//
// 	dependsOn publishToMavenLocal
//
// 	doFirst {
// 		final dest = destProvider.get().asFile.toPath()
//
// 		// deleteFullDir(dest)
// 		if (!dest.deleteDir()) {
// 			throw new GradleException('Failed to delete old output.')
// 		}
// 	}
// 	doLast {
// 		final dest = destProvider.get().asFile.toPath()
//
// 		// deleteFullDir(dest)
// 		// if (!dest.deleteDir()) {
// 		// 	throw new GradleException('Failed to delete old output.')
// 		// }
//
// 		EXEC.exec {
// 			executable 'git'
// 			args 'clone', 'https://github.com/QuiltMC/quilt-mappings', dest
// 		}
//
// 		final versionsFile = dest.resolve('gradle/libs.versions.toml').toFile()
// 		final enigmaPlugin = 'enigma_plugin'
// 		final versionMatcher = versionsFile.text =~ /(?<=$enigmaPlugin = ").*(?=")/
// 		if (versionMatcher.find()) {
// 			replaceRegion(versionsFile, projectVersion.toString(), versionMatcher.start(), versionMatcher.end())
// 		} else {
// 			throw new GradleException("Cannot find $enigmaPlugin version.")
// 		}
//
// 		final classpathHoldersBuildGradle = dest.resolve('buildSrc/classpath-holders/build.gradle').toFile()
//
// 		final enigmaSwing = 'enigmaSwing'
// 		final enigmaServer = 'enigmaServer'
//
// 		def classpathHoldersBuildGradleContents = classpathHoldersBuildGradle.text
// 		[enigmaSwing, enigmaServer].each {
// 			final configMatcher = classpathHoldersBuildGradleContents =~ /(?m)^(\s*)$it libs\.enigma\.plugin/
// 			if (configMatcher.find()) {
// 				final indent = configMatcher.group(1)
//
// 				final changingConfig = indent + """\
// 					$it (libs.enigma.plugin) {
// 					$indent\tchanging = true
// 					$indent}""".stripIndent()
//
// 				classpathHoldersBuildGradleContents = replaceRegion(
// 					classpathHoldersBuildGradleContents,
// 					changingConfig,
// 					configMatcher.start(), configMatcher.end()
// 				)
// 			} else {
// 				throw new GradleException("Cannot find $it configuration.")
// 			}
// 		}
//
// 		classpathHoldersBuildGradleContents += """
// 		configurations {
// 			[$enigmaSwing, $enigmaServer].each {
// 				it.resolutionStrategy {
// 					cacheChangingModulesFor (0, java.util.concurrent.TimeUnit.SECONDS)
// 				}
// 			}
// 		}
// 		""".stripIndent()
//
// 		classpathHoldersBuildGradle.text = classpathHoldersBuildGradleContents
// 	}
// }

tasks.register('setupQmap') {
	final destProvider = layout.buildDirectory.dir('quilt-mappings')
	final projectVersion = project.version

	dependsOn publishToMavenLocal

	inputs.property('projectVersion', projectVersion)
	outputs.tap {
		dir(destProvider)
		upToDateWhen {
			final dest = destProvider.get().asFile.toPath()
			if (!Files.exists(dest.resolve('.git'))) {
				return false
			}

			EXEC.exec {
				workingDir dest
				executable 'git'
				args 'fetch'
			}

			final localHash = new ByteArrayOutputStream()
			EXEC.exec {
				workingDir dest
				executable 'git'
				args 'rev-parse', 'HEAD'
				standardOutput = localHash
			}

			final originHash = new ByteArrayOutputStream()
			EXEC.exec {
				workingDir dest
				executable 'git'
				args 'rev-parse', 'origin/HEAD'
				standardOutput = originHash
			}

			return originHash.toString() == localHash.toString()
		}
	}

	doLast {
		final dest = destProvider.get().asFile.toPath()

		EXEC.exec {
			executable 'chmod'
			args '-Rf', '+w', dest
		}

		dest.deleteDir()

		EXEC.exec {
			executable 'git'
			args 'clone', 'https://github.com/QuiltMC/quilt-mappings', dest
		}

		final versionsFile = dest.resolve('gradle/libs.versions.toml').toFile()
		final enigmaPlugin = 'enigma_plugin'
		final versionMatcher = versionsFile.text =~ /(?<=$enigmaPlugin = ").*(?=")/
		if (versionMatcher.find()) {
			replaceRegion(versionsFile, projectVersion.toString(), versionMatcher.start(), versionMatcher.end())
		} else {
			throw new GradleException("Cannot find $enigmaPlugin version.")
		}

		final classpathHoldersBuildGradle = dest.resolve('buildSrc/classpath-holders/build.gradle').toFile()

		final enigmaSwing = 'enigmaSwing'
		final enigmaServer = 'enigmaServer'

		def classpathHoldersBuildGradleContents = classpathHoldersBuildGradle.text
		[enigmaSwing, enigmaServer].each {
			final configMatcher = classpathHoldersBuildGradleContents =~ /(?m)^(\s*)$it libs\.enigma\.plugin/
			if (configMatcher.find()) {
				final indent = configMatcher.group(1)

				final changingConfig = indent + """\
					$it (libs.enigma.plugin) {
					$indent\tchanging = true
					$indent}""".stripIndent()

				classpathHoldersBuildGradleContents = replaceRegion(
					classpathHoldersBuildGradleContents,
					changingConfig,
					configMatcher.start(), configMatcher.end()
				)
			} else {
				throw new GradleException("Cannot find $it configuration.")
			}
		}

		classpathHoldersBuildGradleContents += """
		configurations {
			[$enigmaSwing, $enigmaServer].each {
				it.resolutionStrategy {
					cacheChangingModulesFor (0, java.util.concurrent.TimeUnit.SECONDS)
				}
			}
		}
		""".stripIndent()

		classpathHoldersBuildGradle.text = classpathHoldersBuildGradleContents
	}
}


license {
	rule file('codeformat/FABRIC_MODIFIED_HEADER')
	rule file('codeformat/HEADER')

	include '**/*.java'
	exclude 'com/example/**/*.java'
}

java {
	sourceCompatibility = JavaVersion.VERSION_17
	targetCompatibility = JavaVersion.VERSION_17

	withSourcesJar()
}

test {
	useJUnitPlatform()
}

publishing {
	publications {
		maven(MavenPublication) {
			from components.java
		}
	}

	repositories {
		if (ENV.MAVEN_URL) {
			maven {
				url = ENV.MAVEN_URL

				credentials {
					username = ENV.MAVEN_USERNAME
					password = ENV.MAVEN_PASSWORD
				}
			}
		}
		mavenLocal()
	}
}
